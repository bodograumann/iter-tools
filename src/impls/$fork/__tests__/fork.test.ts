/* @macrome
 * @generatedby /generate/generators/impls/index.cjs
 * @generatedfrom ./$fork.test.ts#1643907550738
 * This file is autogenerated. Please do not edit it directly.
 * When editing run `npx macrome watch` then change the file this is generated from.
 */
import { _awaitAsyncGenerator, _wrapAsyncGenerator } from '../../../internal/asyncish.js';

import { fork, map } from 'iter-tools-es';
import { wrap, unwrap } from '../../../test/helpers.js';

describe('fork', () => {
  const makeIterable = function* _makeIterable() {
    yield 1;
    yield 2;
    yield 3;
  };

  function _asyncMakeIterable() {
    return _asyncMakeIterable2.apply(this, arguments);
  }

  function _asyncMakeIterable2() {
    _asyncMakeIterable2 = _wrapAsyncGenerator(function* () {
      yield 1;
      yield 2;
      yield 3;
    });

    return _asyncMakeIterable2.apply(this, arguments);
  }

  it('creates an iterable of iterables with the same values as its source', () => {
    const [a, b, c] = fork(makeIterable());
    const originalIter = unwrap(makeIterable());

    expect(unwrap(map((iter) => unwrap(iter), [a, b, c]))).toEqual(Array(3).fill(originalIter));
  });

  it('does not matter which order the fork iterables are consumed in', () => {
    const [a, b, c] = fork(makeIterable());
    const originalIter = unwrap(makeIterable());
    expect(unwrap(map((iter) => unwrap(iter), [c, b, a]))).toEqual(Array(3).fill(originalIter));
  });

  describe('source iterable cleanup', () => {
    /* eslint-disable jest/expect-expect */
    it('happens when a fork is exhausted', () => {
      const iterableIterator = fork(wrap([1, 2, 3]))[Symbol.iterator]();
      unwrap(iterableIterator.next().value);
    });

    it('happens when fork is exhausted and then all forks are exhausted', () => {
      const [a, b] = fork(wrap([1, 2, 3]));
      a[Symbol.iterator]().next();
      a.return();
      b[Symbol.iterator]().next();
      b.return();
    });

    it('happens when all forks are exhausted then fork is exhausted', () => {
      const iterableIterator = fork(wrap([1, 2, 3]))[Symbol.iterator]();

      const a = iterableIterator.next().value;
      a[Symbol.iterator]().next();
      a.return();

      const b = iterableIterator.next().value;
      b[Symbol.iterator]().next();
      b.return();

      iterableIterator.return();
    });

    it('happens even when a fork is closed without being used', () => {
      const [a, b] = fork(wrap([1, 2, 3]));
      a.return();
      b.return();
    });

    /* eslint-enable jest/expect-expect */
  });
});
