/* @macrome
 * @generatedby /generate/generators/impls/index.cjs
 * @generatedfrom ./$forkerate.test.ts#1649946656866
 * This file is autogenerated. Please do not edit it directly.
 * When editing run `npx macrome watch` then change the file this is generated from.
 */
import { _awaitAsyncGenerator, _wrapAsyncGenerator } from '../../../internal/asyncish.js';

import { asyncForkerate, asyncStartsWithSeq, asyncStr } from 'iter-tools-es';
import { asyncWrap, asyncUnwrap } from '../../../test/async-helpers.js';

describe('asyncForkerate', () => {
  describe('forkerator', () => {
    it('yields values from source', async () => {
      expect(await asyncUnwrap((await asyncForkerate(asyncWrap([1, 2, 3]))).asIterator())).toEqual([
        1,
        2,
        3,
      ]);
    });
  });

  describe('fork', () => {
    it('yields values including and after forkr.current', async () => {
      const forkr = await asyncForkerate(asyncWrap([1, 2, 3]));

      expect(await asyncUnwrap(forkr.fork())).toEqual([1, 2, 3]);
      expect(await asyncUnwrap(forkr)).toEqual([1, 2, 3]);

      await forkr.advance();

      expect(await asyncUnwrap(forkr.fork())).toEqual([2, 3]);
      expect(await asyncUnwrap(forkr)).toEqual([2, 3]);

      await forkr.advance();

      expect(await asyncUnwrap(forkr.fork())).toEqual([3]);
      expect(await asyncUnwrap(forkr)).toEqual([3]);

      await forkr.advance();

      expect(await asyncUnwrap(forkr.fork())).toEqual([]);
      expect(await asyncUnwrap(forkr)).toEqual([]);

      expect(await forkr.fork().next()).toEqual({ value: undefined, done: true });
    });

    it('can be advanced more than one value at a time', async () => {
      const forkr = await asyncForkerate(asyncWrap([1, 2, 3]));

      await forkr.advance(2);

      expect(await asyncUnwrap(forkr)).toEqual([3]);
    });
  });

  it('can be used to strip comments', async () => {
    function stripComments(_x) {
      return _stripComments.apply(this, arguments);
    }

    function _stripComments() {
      _stripComments = _wrapAsyncGenerator(function* (source) {
        let forkr = yield _awaitAsyncGenerator(asyncForkerate(source));

        while (true) {
          const isComment = yield _awaitAsyncGenerator(asyncStartsWithSeq('//', forkr.fork()));

          while (!forkr.done && forkr.value !== '\n') {
            if (!isComment) yield forkr.value;
            forkr = yield _awaitAsyncGenerator(forkr.advance());
          }

          if (forkr.done) break;

          if (!isComment) yield '\n';
          forkr = yield _awaitAsyncGenerator(forkr.advance());
        }
      });

      return _stripComments.apply(this, arguments);
    }

    expect(await asyncStr(stripComments('// comment\ncode'))).toBe('code');
  });
});
