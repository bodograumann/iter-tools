/* @macrome
 * @generatedby /generate/generators/impls/index.cjs
 * @generatedfrom ./$interleave.test.ts#1643907550744
 * This file is autogenerated. Please do not edit it directly.
 * When editing run `npx macrome watch` then change the file this is generated from.
 */
import {
  _awaitAsyncGenerator as _awaitAsyncGenerator4,
  _wrapAsyncGenerator as _wrapAsyncGenerator4,
  _awaitAsyncGenerator as _awaitAsyncGenerator3,
  _wrapAsyncGenerator as _wrapAsyncGenerator3,
  _awaitAsyncGenerator as _awaitAsyncGenerator2,
  _wrapAsyncGenerator as _wrapAsyncGenerator2,
  _awaitAsyncGenerator,
  _wrapAsyncGenerator,
} from '../../../internal/asyncish.js';

import { AsyncIterable } from '../../../types/async-iterable.js';
import { asyncInterleave, AsyncPeekerator } from 'iter-tools-es';
import { asyncWrap, asyncUnwrap, asyncUnwrapDeep } from '../../../test/async-helpers.js';

const asyncRoundRobinStrategy = (function () {
  var _ref = _wrapAsyncGenerator(function* (
    options: Record<string, any>,
    all: AsyncPeekerator<AsyncPeekerator<number>>,
    a: AsyncPeekerator<number>,
    b: AsyncPeekerator<number>,
    c: AsyncPeekerator<number>,
  ) {
    while (!all.done) {
      if (!a.done) {
        yield a.value;
        yield _awaitAsyncGenerator(a.advance());
      }
      if (!b.done) {
        yield b.value;
        yield _awaitAsyncGenerator(b.advance());
      }
      if (!c.done) {
        yield c.value;
        yield _awaitAsyncGenerator(c.advance());
      }
    }
  });

  return function (_x, _x2, _x3, _x4, _x5) {
    return _ref.apply(this, arguments);
  };
})();

const asyncRoundRobin = asyncInterleave(asyncRoundRobinStrategy, {});

describe('asyncInterleave', () => {
  describe('when there are only empty sources', () => {
    it('yields no values', async () => {
      expect(await asyncUnwrap(asyncRoundRobin(null, undefined, []))).toEqual([]);
    });
  });

  describe('when all sources are the same size', () => {
    it('yields all values collated', async () => {
      const sources = [asyncWrap([1, 2, 3]), asyncWrap([4, 5, 6]), asyncWrap([7, 8, 9])];
      expect(await asyncUnwrap(asyncRoundRobin(...sources))).toEqual([1, 4, 7, 2, 5, 8, 3, 6, 9]);
    });
  });

  describe('when sources are different sizes', () => {
    it('yields all values collated', async () => {
      const sources = [asyncWrap([]), asyncWrap([1, 2, 3]), asyncWrap([4])];
      expect(await asyncUnwrap(asyncRoundRobin(...sources))).toEqual([1, 4, 2, 3]);
    });
  });

  describe('when the interleave generator does not yield all values', () => {
    it('closes the source iterables', async () => {
      const asyncIncompleteInterleave = asyncInterleave(_wrapAsyncGenerator2(function* () {}));

      expect(
        await asyncUnwrap(asyncIncompleteInterleave(asyncWrap([1, 2, 3]), asyncWrap([4, 5, 6]))),
      ).toEqual([]);
    });
  });

  describe('when the interleave is terminated abruptly', () => {
    // eslint-disable-next-line jest/expect-expect
    it('calls return on the strategy', async () => {
      const iter = asyncInterleave(
        // @ts-ignore
        (...args) => asyncWrap(asyncRoundRobinStrategy(...args)),
        {},
        asyncWrap([1, 2, 3]),
        asyncWrap([4, 5, 6]),
      );
      await iter.next();
      await iter.next();
      await iter.return();
    });
  });

  it('can be passed options for the generator', async () => {
    const options = {};

    expect.assertions(1);
    await asyncUnwrap(
      asyncInterleave(
        (function () {
          var _ref3 = _wrapAsyncGenerator3(function* (o: Record<string, any>): AsyncIterable<any> {
            expect(o).toBe(options);
          });

          return function (_x6) {
            return _ref3.apply(this, arguments);
          };
        })(),
        options,
        null,
      ),
    );
  });

  describe('the summary', () => {
    it('summary.value is a buffer', async () => {
      const asyncConcat = asyncInterleave(
        (function () {
          var _ref4 = _wrapAsyncGenerator4(function* (
            _: Record<string, any>,
            all: AsyncPeekerator<AsyncPeekerator<number>>,
          ) {
            let first = true;
            while (!all.done) {
              if (first) {
                // eslint-disable-next-line jest/no-conditional-expect
                expect(() => all.advance()).toThrowErrorMatchingSnapshot();
              }
              expect(all.current.done).toBe(all.done);
              expect(all.current.value).toBe(all.value);
              const { value: buffer, index } = all;
              yield { value: buffer.value, index };
              yield _awaitAsyncGenerator4(buffer.advance());
              first = false;
            }
          });

          return function (_x7, _x8) {
            return _ref4.apply(this, arguments);
          };
        })(),
      );

      expect(
        await asyncUnwrapDeep(asyncConcat(asyncWrap([1]), asyncWrap([2]), asyncWrap([3]))),
      ).toEqual([
        {
          index: 0,
          value: 1,
        },
        {
          index: 1,
          value: 2,
        },
        {
          index: 2,
          value: 3,
        },
      ]);
    });
  });
});
