/* @macrome
 * @generatedby /generate/generators/impls/index.cjs
 * @generatedfrom ./$split-on-any-seq.js#1643907550760
 * This file is autogenerated. Please do not edit it directly.
 * When editing run `npx macrome watch` then change the file this is generated from.
 */
import {
  _awaitAsyncGenerator as _awaitAsyncGenerator3,
  _wrapAsyncGenerator as _wrapAsyncGenerator2,
  _awaitAsyncGenerator as _awaitAsyncGenerator2,
  _asyncIterator as _asyncIterator2,
  _asyncGeneratorDelegate,
  _awaitAsyncGenerator,
  _wrapAsyncGenerator,
  _asyncIterator,
} from '../../internal/asyncish.js';

import { asyncIterableCurry } from '../../internal/async-iterable.js';
import { asyncSeqsToArray } from '../../internal/async-any-seq.js';
import { __startsWithSeq } from '../$starts-with-seq/starts-with-seq.js';
import { __asyncWindowAhead } from '../$window-ahead/async-window-ahead.js';
import { __asyncSpliterate } from '../$spliterate/async-spliterate.js';

function getMatchingLength(buffer, separatorSeqs, same) {
  for (const subsequence of separatorSeqs) {
    if (__startsWithSeq(buffer, subsequence, same)) {
      return subsequence.length;
    }
  }

  return 0;
}

function asyncAnySeqspliterator(_x, _x2, _x3) {
  return _$anySeqspliterator.apply(this, arguments);
}

function _$anySeqspliterator() {
  _$anySeqspliterator = _wrapAsyncGenerator(function* (split, { separatorSeqs, same }, source) {
    const maxMatchLength = separatorSeqs.reduce((max, { length }) => Math.max(max, length), 1);

    let skip = 0;

    let _iteratorAbruptCompletion = false;
    let _didIteratorError = false;
    let _iterator;
    let _iteratorError;

    try {
      _iterator = _asyncIterator(__asyncWindowAhead(source, maxMatchLength, { useFiller: false }));
      for (
        let _step, _step2;
        (_step2 = _iterator.next()),
          (_iteratorAbruptCompletion = !(_step =
            !(_step2 instanceof Promise) && !(_step2.value instanceof Promise)
              ? _step2
              : yield _awaitAsyncGenerator(_step2)).done);
        _iteratorAbruptCompletion = false
      ) {
        const buffer = _step.value;
        if (skip > 0) {
          skip--;
          continue;
        }
        const matchingLength = getMatchingLength(buffer, separatorSeqs, same);

        if (matchingLength > 0) {
          yield split;
          skip = matchingLength - 1;
        } else {
          yield buffer.get(0);
        }
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (_iteratorAbruptCompletion && _iterator.return != null) {
          yield _awaitAsyncGenerator(_iterator.return());
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }
  });

  return _$anySeqspliterator.apply(this, arguments);
}

export function __asyncSplitOnAnySeq(_x4, _x5) {
  return _$__splitOnAnySeq.apply(this, arguments);
}

function _$__splitOnAnySeq() {
  _$__splitOnAnySeq = _wrapAsyncGenerator2(function* (source, separatorSeqs, same = Object.is) {
    const separatorSeqsArr = (yield _awaitAsyncGenerator3(asyncSeqsToArray(separatorSeqs))).filter(
      (s) => s.length > 0,
    );

    yield* _asyncGeneratorDelegate(
      _asyncIterator2(
        __asyncSpliterate(source, asyncAnySeqspliterator, {
          separatorSeqs: separatorSeqsArr.sort((a, b) => b.length - a.length),
          same,
        }),
      ),
      _awaitAsyncGenerator2,
    );
  });

  return _$__splitOnAnySeq.apply(this, arguments);
}

export const asyncSplitOnAnySeq = /*#__PURE__*/ asyncIterableCurry(__asyncSplitOnAnySeq, {
  minArgs: 1,
  maxArgs: 2,
});
