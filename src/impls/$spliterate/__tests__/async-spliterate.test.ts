/* @macrome
 * @generatedby /generate/generators/impls/index.cjs
 * @generatedfrom ./$spliterate.test.ts#1643907550767
 * This file is autogenerated. Please do not edit it directly.
 * When editing run `npx macrome watch` then change the file this is generated from.
 */
import {
  _awaitAsyncGenerator as _awaitAsyncGenerator4,
  _wrapAsyncGenerator as _wrapAsyncGenerator2,
  _awaitAsyncGenerator as _awaitAsyncGenerator3,
  _asyncIterator as _asyncIterator2,
  _asyncGeneratorDelegate as _asyncGeneratorDelegate2,
  _awaitAsyncGenerator as _awaitAsyncGenerator2,
  _wrapAsyncGenerator,
  _awaitAsyncGenerator,
  _asyncIterator,
  _asyncGeneratorDelegate,
} from '../../../internal/asyncish.js';

import { asyncSpliterate } from 'iter-tools-es';
import { asyncWrap, asyncUnwrapDeep } from '../../../test/async-helpers.js';

function asyncIdentityStrategy(_x, _x2, _x3) {
  return _$identityStrategy.apply(this, arguments);
}

function _$identityStrategy() {
  _$identityStrategy = _wrapAsyncGenerator(function* (_split: any, _options: any, source: any) {
    yield* _asyncGeneratorDelegate(_asyncIterator(source), _awaitAsyncGenerator);
  });

  return _$identityStrategy.apply(this, arguments);
}

describe('asyncSpliterate', () => {
  let split: symbol;
  const asyncTestSpliterator = asyncSpliterate(
    (function () {
      var _ref = _wrapAsyncGenerator2(function* (split_: any, options: any, source: any) {
        split = split_;
        yield* _asyncGeneratorDelegate2(
          _asyncIterator2(asyncIdentityStrategy(split_, options, source)),
          _awaitAsyncGenerator3,
        );
      });

      return function (_x4, _x5, _x6) {
        return _ref.apply(this, arguments);
      };
    })(),
    {},
  );

  describe('when spliterator is empty', () => {
    it('yields no groups', async () => {
      expect(await asyncUnwrapDeep(asyncTestSpliterator(asyncWrap([])))).toEqual([]);
    });
  });

  describe('when spliterator contains only a split', () => {
    it('yields two empty groups', async () => {
      expect(await asyncUnwrapDeep(asyncTestSpliterator(asyncWrap([split])))).toEqual([[], []]);
    });
  });

  describe('when spliterator contains two splits', () => {
    it('yields three empty groups', async () => {
      expect(await asyncUnwrapDeep(asyncTestSpliterator(asyncWrap([split, split])))).toEqual([
        [],
        [],
        [],
      ]);
    });
  });

  describe('when spliterator contains a trailing split', () => {
    it('yields three empty groups', async () => {
      expect(await asyncUnwrapDeep(asyncTestSpliterator(asyncWrap([null, split])))).toEqual([
        [null],
        [],
      ]);
    });
  });

  describe('when spliterator contains a leading split', () => {
    it('yields three empty groups', async () => {
      expect(await asyncUnwrapDeep(asyncTestSpliterator(asyncWrap([split, null])))).toEqual([
        [],
        [null],
      ]);
    });
  });

  describe('abrupt termination', () => {
    // The assertions in these tests are part of the cleanup defined by $wrap
    /* eslint-disable jest/expect-expect */

    it("source is cleaned up if we're done before we started", async () => {
      const parts = asyncTestSpliterator(asyncWrap(['first', split, 'second']));
      await parts.return();
    });

    it('source is cleaned up if part manager is closed then active part', async () => {
      const parts = asyncTestSpliterator(asyncWrap(['first', split, 'second']));
      const part = (await parts.next()).value;
      await part.next();
      await parts.return();
      await part.return();
    });

    it('source is cleaned up if active part is closed then part manager', async () => {
      const parts = asyncTestSpliterator(asyncWrap(['first', split, 'second']));
      const part = (await parts.next()).value;
      await part.next();
      await part.return();
      await parts.return();
    });

    it('source is cleaned up if active part is done then part manager is closed', async () => {
      const parts = asyncTestSpliterator(asyncWrap(['first', split, 'second']));
      const part = (await parts.next()).value;
      await part.next();
      await part.next();
      await parts.return();
    });

    it('source is cleaned up if part manager is closed then active part is done', async () => {
      const parts = asyncTestSpliterator(asyncWrap(['first', split, 'second']));
      const part = (await parts.next()).value;
      await parts.return();
      await part.next();
      await part.next();
    });

    it('source is cleaned up if only parts are consumed', async () => {
      const parts = asyncTestSpliterator(asyncWrap(['first', split, 'second']));
      await parts.next();
      await parts.next();
      await parts.next();
    });

    /* eslint-enable jest/expect-expect */
  });

  it('options may be omitted', async () => {
    const asyncTestSpliterator = asyncSpliterate(asyncIdentityStrategy);
    expect(await asyncUnwrapDeep(asyncTestSpliterator([]))).toEqual([]);
  });
});
