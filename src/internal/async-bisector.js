/* @macrome
 * @generatedby /generate/generators/impls/index.cjs
 * @generatedfrom ./$bisector.js#1643907550813
 * This file is autogenerated. Please do not edit it directly.
 * When editing run `npx macrome watch` then change the file this is generated from.
 */
import {
  _awaitAsyncGenerator as _awaitAsyncGenerator4,
  _wrapAsyncGenerator as _wrapAsyncGenerator2,
  _awaitAsyncGenerator as _awaitAsyncGenerator3,
  _asyncIterator as _asyncIterator2,
  _asyncGeneratorDelegate as _asyncGeneratorDelegate2,
  _awaitAsyncGenerator as _awaitAsyncGenerator2,
  _wrapAsyncGenerator,
  _awaitAsyncGenerator,
  _asyncIterator,
  _asyncGeneratorDelegate,
} from '../internal/asyncish.js';

import { IterableIterator } from './iterable-iterator.js';
import { AsyncPartsIterator } from './async-parts-iterator.js';

/**
 * Split an iterable into two parts.
 * Since we know there will be two parts always present them synchronously.
 * This enables consumption as `const [first, second] = asyncMethod(...)`;
 * Any currying of the results must be done with `{ forceSync: true }`
 */
export class AsyncBisector extends IterableIterator {
  constructor(source, strategy, options) {
    super();
    this.source = source;
    this.strategy = strategy;
    this.options = options;

    this.partsIterator = null;
    this.firstPart = null;
    this.secondPart = null;
    this.currentIdx = 0;
  }

  async setupFirst() {
    const { source, strategy, options } = this;
    this.partsIterator = this.partsIterator || new AsyncPartsIterator(source, strategy, options);
    if (!this.firstPart) {
      const step = await this.partsIterator.next();
      this.firstPart = step.done ? [] : step.value;
    }
  }

  // never async
  next() {
    const self = this;
    switch (this.currentIdx++) {
      case 0:
        return {
          value: _wrapAsyncGenerator(function* () {
            yield _awaitAsyncGenerator2(self.setupFirst());

            yield* _asyncGeneratorDelegate(_asyncIterator(self.firstPart), _awaitAsyncGenerator);
          })(),
          done: false,
        };

      case 1:
        return {
          value: _wrapAsyncGenerator2(function* () {
            yield _awaitAsyncGenerator4(self.setupFirst());

            const step = yield _awaitAsyncGenerator4(self.partsIterator.next());
            self.secondPart = step.done ? [] : step.value;

            yield* _asyncGeneratorDelegate2(
              _asyncIterator2(self.secondPart),
              _awaitAsyncGenerator3,
            );
          })(),
          done: false,
        };

      default:
        return { value: undefined, done: true };
    }
  }

  return() {
    // If one part is taken but not the other we could never safely call
    // return() on the source in the async version.
    if (this.currentIdx === 1) {
      // Generator syntax will not let you do this.
      // You can't throw an error safely inside a finally block
      throw new Error('You must take both parts of a bisector or neither.');
    }
    return { value: undefined, done: true };
  }
}
