/* @macrome
 * @generatedby /generate/generators/impls/index.cjs
 * @generatedfrom ./$wrap.js#1643907550855
 * This file is autogenerated. Please do not edit it directly.
 * When editing run `npx macrome watch` then change the file this is generated from.
 */
import {
  _awaitAsyncGenerator as _awaitAsyncGenerator2,
  _wrapAsyncGenerator,
  _awaitAsyncGenerator,
  _asyncIterator,
  _asyncGeneratorDelegate,
} from '../../internal/asyncish.js';

const wrappedIterables = [];

function asyncWrap_(_x) {
  return _$wrap_.apply(this, arguments);
}

function _$wrap_() {
  _$wrap_ = _wrapAsyncGenerator(function* (iterable) {
    yield* _asyncGeneratorDelegate(_asyncIterator(iterable), _awaitAsyncGenerator);
  });

  return _$wrap_.apply(this, arguments);
}

class AsyncTestWrapper {
  constructor(source, deep = false) {
    this.source = source[Symbol.asyncIterator]();
    this.deep = deep;
    this.started = false;
    this.returned = false;
    this.done = false;

    wrappedIterables.push(this);
  }

  async next() {
    this.started = true;
    const { done, value } = await this.source.next();
    this.done = done;

    return {
      value:
        this.deep && Array.isArray(value) ? new AsyncTestWrapper(asyncWrap_(value), true) : value,
      done,
    };
  }

  async return(value) {
    if (this.done) {
      throw new Error('Called return on an iterator that was done');
    }
    this.returned = this.done = true;
    await this.source.return();
    return { value, done: true };
  }

  [Symbol.asyncIterator]() {
    return this;
  }
}

export function asyncWrap(iterable) {
  return new AsyncTestWrapper(asyncWrap_(iterable));
}

export function asyncWrapDeep(iterable) {
  return new AsyncTestWrapper(asyncWrap_(iterable), true);
}

beforeEach(() => {
  wrappedIterables.length = 0;
});

afterEach(() => {
  for (const wrapped of wrappedIterables) {
    if (wrapped.started && !wrapped.done) {
      throw new Error('Not all iterables returned');
    }
  }
});
